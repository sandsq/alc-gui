# See ending comments for field information.
[layout_info]
num_rows = 4
num_cols = 10
layout = """
___Layer 0___
         0       1       2       3       4       5       6       7       8       9 
0|   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10 
1|   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10 
2|  SFT_11   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10  SFT_11 
3|   NO_00   NO_00   NO_00  LS1_00  SPC_00 BSPC_00  LS2_00   NO_00   NO_00   NO_00 
___Layer 1___
         0       1       2       3       4       5       6       7       8       9 
0|   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10 
1|   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10 
2|   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10 
3|   NO_00   NO_00   NO_00  LS1_00   NO_10   NO_10   NO_10   NO_00   NO_00   NO_00 
___Layer 2___
         0       1       2       3       4       5       6       7       8       9 
0|    1_00    2_00    3_00    4_00    5_00    6_00    7_00    8_00    9_00 ZERO_00 
1|   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10 
2|   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10   NO_10 
3|   NO_00   NO_00   NO_00   NO_10   NO_10   NO_10  LS2_00   NO_00   NO_00   NO_00 
"""
effort_layer = """
      0    1    2    3    4    5    6    7    8    9 
0|   7   2   2   2   7   7   2   2   2   7 
1|   3   1   1   1   3   3   1   1   1   3 
2|   5   3   3   3   8   8   3   3   3   5 
3|  10   7   4   2   1   1   2   4   7  10 
"""
phalanx_layer = """
      0    1    2    3    4    5    6    7    8    9 
0| l:p l:r l:m l:i l:i r:i r:i r:m r:r r:p 
1| l:p l:r l:m l:i l:i r:i r:i r:m r:r r:p 
2| l:p l:r l:m l:i l:i r:i r:i r:m r:r r:p 
3| l:p l:r l:t l:t l:t r:t r:t r:t r:r r:p 
"""

[layout_optimizer_config]
valid_keycodes = []
num_threads = 8

[layout_optimizer_config.genetic_options]
population_size = 10000
generation_count = 100
fitness_cutoff = 0.1
swap_weight = 2.0
replace_weight = 1.0

[layout_optimizer_config.keycode_options]
include_alphas = true
include_numbers = false
include_number_symbols = false
include_brackets = false
include_misc_symbols = true
include_misc_symbols_shifted = false
explicit_inclusions = []

[layout_optimizer_config.dataset_options]
dataset_paths = []
dataset_weights = []
max_ngram_size = 4
top_n_ngrams_to_take = 100

[layout_optimizer_config.score_options]
hand_alternation_weight = 1.0
finger_roll_weight = 1.0
hand_alternation_reduction_factor = 0.8
finger_roll_reduction_factor = 0.8
finger_roll_same_row_reduction_factor = 0.9
same_finger_penalty_factor = 5.0
extra_length_penalty_factor = 1.5

# [Autogenerated]
# Option info (note: some descriptions may not be totally accurate due to complexity, but the general idea should be present.)

# [layout_info]
# num_rows: Number of rows in the layout. Note that some row x column combinations may not exist, in which case use the next size up and block key positions as necessary. Available sizes should be listed here at some point: 
# num_cols: Number of columns in the layout.
# layout: Collection of layers. Each key is of the format {{keycode}}_{{moveability flag}}{{symmetry flag}}. Keycode reference should be available here: . Moveability of 1 means the optimizer can change the key in the given position; otherwise, the key will be fixed. Symmetry of 1 means it and its corresponding symmetric key will be locked in symmetry -- if one moves, the other will be moved to the corresponding symmetric location.
# effort_layer: Specify the relative effort required to reach each key position. Smaller number means lower effort. Recommended to make the most accessible keys a weight of 1 and scale other keys accordingly. Does require some tinkering to create a grid that works for you.
# phalanx_layer: Specify which hand and finger you want to use for each key. Used in calculating hand alternation bonuses, roll bonuses, and same finger penalties. Format is {{hand}}:{{finger}}, with hand options (L)eft and (R)ight and finger options (T)humb, (I)ndex, (M)iddle, (R)ing, (P)inkie, and (J)oint. Joint refers to where your pinkie meets your palm; some users use this part of their hand to hit the bottom left- / bottom right-most keys.

# [layout_optimizer_config]
# valid_keycodes: Recommended to leave empty, as these will be generated from keycode options. If keycodes are supplied here, they will override keycode options; however, you can simply use the options + `explicit_inclusions` to fine tune the set you want, rather than having to list everything out here.
# num_threads: Number of threads to parallelize score calculation over. The user should check their CPU's spec sheet for the maximum number of threads available and reduce that count by a few to avoid issues that I don't really understand. .

# [layout_optimizer_config.genetic_options]
# population_size: Number of layouts per generation. A larger population means that more layouts are explored per generation, at the cost of execution time.
# generation_count: Number of generations. More generations generally mean better layouts, at the cost of execution time.
# fitness_cutoff: Fraction of best layouts per generation to duplicate and modify into layouts of the next generation. With a value of 1.0, all layouts will be retained generation to generation so no new ones will be created. With a value of 0.0, a single layout (the minimum possible) will be retained generation to generation; all layouts within a generation will be based on the best layout of the previous generation.
# swap_weight: swap_weight:replace_weight represents the ratio of swap mutations (i.e., swapping two keys) to replace mutations (i.e., replacing one key with another).
# replace_weight: See swap_weight.

# [layout_optimizer_config.keycode_options]
# include_alphas: Convenience toggle. Recommended to be set to true, as otherwise the user must manually place every alpha.
# include_numbers: Whether to include number keycodes. Recommended to set this to false with manual number placement -- optimized layouts cannot currently guarantee numbers to be arranged in order.
# include_number_symbols: Whether shifted numbers (!@#$ etc.) should be considered their own keycodes. If false, these symbols must be accessed through shift+numbers. Recommended to set to false, as it is uncommon for general typing to need immediate access to all such symbols. Instead, include specific symbols, such as ones common to a programming language, via `explicit_inclusions`.
# include_brackets: Whether the various brackets ()[]{}<> should be considered their own keycodes. (Note that "[]" will always be considered their own keycodes since they are base, non-shifted keys.) If users prefer symmetrically placed brackets, recommended to set to true with manual initial symmetric placements. Otherwise, set to false.
# include_misc_symbols: Convenience toggle. -=\;'`/[] Set to true or manually place in the layout, as these are required for typing.
# include_misc_symbols_shifted: Whether shifted versions of misc. symbols, i.e., _+|:"~?{} should be considered their own keycodes. Recommended to set to false, as it is uncommon for general typing to need immediate access to all such symbols. Instead, include specific symbols via `explicit_inclusions`.
# explicit_inclusions: Keycodes to explicitly include, for if no combination of options covers exactly what the user wants. If not manually added to the layout, shift (SFT) should be included here.

# [layout_optimizer_config.dataset_options]
# dataset_paths: Path to directories containing textual data. Currently only looks in the immediate directory and not recursively. Presets are planned.
# dataset_weights: Ratio of datasets' importance. For example, with two datasets at a 2:1 ratio, the first dataset will constitute 2/(2 + 1) of the score and the second will constitute 1/(2 + 1).
# max_ngram_size: Maximum length of ngrams to extract from text. Recommended to set to 4.
# top_n_ngrams_to_take: Number of most frequent ngrams to include. Some ngrams barely occur, thus having very little impact on overall score, so excluding them can decrease runtime. Applies to all ngram sizes. For example, if this value is 50, then the top 50 characters, top 50 bigrams, top 50 trigrams, etc., are taken

# [layout_optimizer_config.score_options]
# hand_alternation_weight: hand_alteration_weight:finger_roll_weight represents the importance of hand alternation vs. finger rolls.
# finger_roll_weight: See `hand_alteration_weight`.
# hand_alternation_reduction_factor: When a sequence of at least 3 keys alternates hands, the total effort of that sequence is multiplied by this factor. In other words, sequences of hand alternations require lower effort than their constituent keys.
# finger_roll_reduction_factor: When a sequence of at least 3 keys is a finger roll, the effort of that sequence is multiplied by this factor. Sequential keys that cross two or more rows are not eligible for rolls. Inner and outer rolls are weighed the same (for now).
# finger_roll_same_row_reduction_factor: If a roll occurs where all fingers are in the same row, the effort of that sequence is multiplied by this factor, on top of the standard roll reduction factor. In other words, rolls where all keys are in the same row are extra favorable.
# same_finger_penalty_factor: If the same finger (on the same hand, of course) is used twice in a row, the effort is multiplied by this factor. In other words, repeating the same finger is unfavorable.
# extra_length_penalty_factor: If the keycode sequence is longer than the ngram (e.g., from layer switches or shifting), the effort of that sequence is multiplied by this factor.
