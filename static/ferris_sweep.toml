# See ending comments for field information.
[layout_info]
num_rows = 4
num_cols = 10
layout = """
___Layer 0___
        0       1       2       3       4       5       6       7       8       9 
0|   __10    __10    __10    __10    __10    __10    __10    __10    __10    __10 
1|   __10    __10  LS3_10    __10    __10    __10    __10    __10    __10    __10 
2| SFT_11    __10    __10    __10    __10    __10    __10    __10    __10  SFT_11 
3|   __00    __00    __00  LS1_00  SPC_00 BSPC_00  LS2_00    __00    __00    __00 

___Layer 1___
        0       1       2       3       4       5       6       7       8       9 
0|   __10    __10    __10    __10    __10    __10    __10    __10    __10    __10 
1|   __10 LCBR_00 LBRC_00 LPRN_00    __10    __10 RPRN_00 RBRC_00 RCBR_00    __10 
2|   __10    __10    __10    __10    __10    __10    __10    __10    __10    __10 
3|   __00    __00    __00    __10    __10    __10    __10    __00    __00    __00 

___Layer 2___
        0       1       2       3       4       5       6       7       8       9 
0|   1_00    2_00    3_00    4_00    5_00    __10    __10    __10    __10    __10 
1|   6_00    7_00    8_00    9_00 ZERO_00    __10 LEFT_00 DOWN_00   UP_00 RGHT_00 
2|   __10    __10    __10    __10    __10    __10 HOME_00 PGDN_00 PGUP_00  END_00 
3|   __00    __00    __00    __10    __10    __10    __10    __00    __00    __00 

___Layer 3___
        0       1       2       3       4       5       6       7       8       9 
0|   __10    __10    __10    __10    __10    __10    __10    __10    __10    __10 
1|   __10    __10    __10    __10    __10    __10    __10    __10    __10    __10 
2|   __10    __10    __10    __10    __10    __10    __10    __10    __10    __10 
3|   __00    __00    __00    __10    __10    __10    __10    __00    __00    __00 

"""
effort_layer = """
     0    1    2    3    4    5    6    7    8    9 
0| 7.0  2.0  2.0  2.0  7.0  7.0  2.0  2.0  2.0  7.0 
1| 3.0  1.0  1.0  1.0  3.0  3.0  1.0  1.0  1.0  3.0 
2| 5.0  3.0  3.0  3.0  8.0  8.0  3.0  3.0  3.0  5.0 
3|10.0  7.0  4.0  2.0  1.0  1.0  2.0  4.0  7.0 10.0 
"""
phalanx_layer = """
     0    1    2    3    4    5    6    7    8    9 
0| L:P  L:R  L:M  L:I  L:I  R:I  R:I  R:M  R:R  R:P 
1| L:P  L:R  L:M  L:I  L:I  R:I  R:I  R:M  R:R  R:P 
2| L:P  L:R  L:M  L:I  L:I  R:I  R:I  R:M  R:R  R:P 
3| L:P  L:R  L:T  L:T  L:T  R:T  R:T  R:T  R:R  R:P 
"""

[layout_optimizer_config]
valid_keycodes = []
num_threads = 16

[layout_optimizer_config.genetic_options]
population_size = 1000
generation_count = 10
fitness_cutoff = 0.1
swap_weight = 2.0
replace_weight = 1.0

[layout_optimizer_config.keycode_options]
include_alphas = true
include_numbers = false
include_number_symbols = true
include_brackets = false
include_misc_symbols = true
include_misc_symbols_shifted = false
explicit_inclusions = ["_SPC", "_SFT", "_ENT"]

[layout_optimizer_config.dataset_options]
dataset_paths = ["~/coding/rustprog/alc/alc-rs/data/rust_book_test/", "~/coding/rustprog/alc/alc-rs/data/rust_book/"]
dataset_weights = [0.1, 1.0]
max_ngram_size = 4
top_n_ngrams_to_take = 100

[layout_optimizer_config.score_options]
hand_alternation_weight = 3.0
finger_roll_weight = 2.0
hand_alternation_reduction_factor = 0.8
finger_roll_reduction_factor = 0.8
finger_roll_same_row_reduction_factor = 0.9
same_finger_penalty_factor = 5.0
extra_length_penalty_factor = 1.2

# [Autogenerated]
# Option info (note: some descriptions may not be totally accurate due to complexity, but the general idea should be present.)

# [layout_info]
# num_rows: Number of rows in the layout. Note that some row x column combinations may not exist, in which case use the next size up and block key positions as necessary. Available sizes should be listed here at some point: 
# num_cols: Number of columns in the layout.
# layout: Collection of layers. Each key is of the format {{keycode}}_{{moveability flag}}{{symmetry flag}}. Keycode reference should be available here: . Moveability of 1 means the optimizer can change the key in the given position; otherwise, the key will be fixed. Symmetry of 1 means it and its corresponding symmetric key will be locked in symmetry -- if one moves, the other will be moved to the corresponding symmetric location.
# effort_layer: Specify the relative effort required to reach each key position. Smaller number means lower effort. Recommended to make the most accessible keys a weight of 1 and scale other keys accordingly. Does require some tinkering to create a grid that works for you.
# phalanx_layer: Specify which hand and finger you want to use for each key. Used in calculating hand alternation bonuses, roll bonuses, and same finger penalties. Format is {{hand}}:{{finger}}, with hand options (L)eft and (R)ight and finger options (T)humb, (I)ndex, (M)iddle, (R)ing, (P)inkie, and (J)oint. Joint refers to where your pinkie meets your palm; some users use this part of their hand to hit the bottom left- / bottom right-most keys.

# [layout_optimizer_config]
# valid_keycodes: Recommended to leave empty, as these will be generated from keycode options. If keycodes are supplied here, they will override keycode options; however, you can simply use the options + `explicit_inclusions` to fine tune the set you want, rather than having to list everything out here.
# num_threads: Number of threads to parallelize score calculation over. The user should check their CPU's spec sheet for the maximum number of threads available and reduce that count by a few to avoid issues that I don't really understand. .

# [layout_optimizer_config.genetic_options]
# population_size: Number of layouts per generation. A larger population means that more layouts are explored per generation, at the cost of execution time.
# generation_count: Number of generations. More generations generally mean better layouts, at the cost of execution time.
# fitness_cutoff: Fraction of best layouts per generation to duplicate and modify into layouts of the next generation. With a value of 1.0, all layouts will be retained generation to generation so no new ones will be created. With a value of 0.0, a single layout (the minimum possible) will be retained generation to generation; all layouts within a generation will be based on the best layout of the previous generation.
# swap_weight: swap_weight:replace_weight represents the ratio of swap mutations (i.e., swapping two keys) to replace mutations (i.e., replacing one key with another).
# replace_weight: See swap_weight.

# [layout_optimizer_config.keycode_options]
# include_alphas: Whether to include alphabet keycodes. Recommended to be set to true, as otherwise the user must manually place every alpha.
# include_numbers: Whether to include number keycodes. Recommended to set this to false with manual number placement -- optimized layouts cannot currently guarantee numbers to be arranged in order.
# include_number_symbols: Whether to include shifted numbers (!@#$ etc.). If false, these symbols must be accessed through shifted numbers. Recommended to set to false. For specific symbols, such as ones common to programming languages, include them in `explicit_inclusions`.
# include_brackets: Whether to include ()[]{}<> Recommended to set to false with manual bracket placement, as optimized layouts cannot guarantee corresponding brackets will appear next to each other.
# include_misc_symbols: Whether to include -=\;'`/[] Set to true or manually place in the layout, as these are needed for typing.
# include_misc_symbols_shifted: Whether to include shifted versions of misc. symbols, i.e., _+|:"~?{} Recommended to set to false and access through shift.
# explicit_inclusions: Keycodes to explicitly include. If no combination of options covers exactly what you want, add them here.

# [layout_optimizer_config.dataset_options]
# dataset_paths: Path to directories containing textual data. Currently only looks in the immediate directory and not recursively. Presets are planned.
# dataset_weights: Ratio of datasets' importance. For example, with two datasets at a 2:1 ratio, the first dataset will constitute 2/(2 + 1) of the score and the second will constitute 1/(2 + 1).
# max_ngram_size: Maximum length of ngrams to extract from text. Recommended to set to 4.
# top_n_ngrams_to_take: Number of most frequent ngrams to include. Some ngrams barely occur, thus having very little impact on overall score, so excluding them can decrease runtime. Applies to all ngram sizes. For example, if this value is 50, then the top 50 characters, top 50 bigrams, top 50 trigrams, etc., are taken

# [layout_optimizer_config.score_options]
# hand_alternation_weight: hand_alteration_weight:finger_roll_weight represents the importance of hand alternation vs. finger rolls.
# finger_roll_weight: See `hand_alteration_weight`.
# hand_alternation_reduction_factor: When a sequence of at least 3 keys alternates hands, the total effort of that sequence is multiplied by this factor. In other words, sequences of hand alternations require lower effort than their constituent keys.
# finger_roll_reduction_factor: When a sequence of at least 3 keys is a finger roll, the effort of that sequence is multiplied by this factor. Sequential keys that cross two or more rows are not eligible for rolls. Inner and outer rolls are weighed the same (for now).
# finger_roll_same_row_reduction_factor: If a roll occurs where all fingers are in the same row, the effort of that sequence is multiplied by this factor, on top of the standard roll reduction factor. In other words, rolls where all keys are in the same row are extra favorable.
# same_finger_penalty_factor: If the same finger (on the same hand, of course) is used twice in a row, the effort is multiplied by this factor. In other words, repeating the same finger is unfavorable.
# extra_length_penalty_factor: If the keycode sequence is longer than the ngram (e.g., from layer switches or shifting), the effort of that sequence is multiplied by this factor.
