# See ending comments for field information.
[layout_info]
num_rows = 4
num_cols = 10
layout = """
___Layer 0___
        0       1       2       3       4       5       6       7       8       9 
0|   __10    H_10    H_10    I_10    __10    __10    P_10 SLSH_10    G_10    Z_10 
1|   O_10    E_10  LS3_10    N_10    K_10    W_10    S_10    A_10    T_10    D_10 
2|   __10    U_10    V_10    __10    __10  SPC_10    I_10    F_10    Y_10    __10 
3|   __00    __00    __00  LS1_00  SPC_00 BSPC_00  LS2_00    __00    __00    __00 

___Layer 1___
        0       1       2       3       4       5       6       7       8       9 
0|   __10  SFT_10    __10 QUOT_10  EQL_10    __10    __10    __10 MINS_10    __10 
1|   __10 LCBR_00 LBRC_00 LPRN_00    __10    __10 RPRN_00 RBRC_00 RCBR_00    __10 
2|   __10    __10    __10    __10    __10    __10    X_10    __10    Q_10    __10 
3|   __00    __00    __00    __00    J_10    R_10    __10    __00    __00    __00 

___Layer 2___
        0       1       2       3       4       5       6       7       8       9 
0|   1_00    2_00    3_00    4_00    5_00    __10    B_10    __10  DOT_10    __10 
1|   6_00    7_00    8_00    9_00 ZERO_00    __10 LEFT_00 DOWN_00   UP_00 RGHT_00 
2|   __10    P_10    __10    __10    __10    __10 HOME_00 PGDN_00 PGUP_00  END_00 
3|   __00    __00    __00    __10    Y_10    __10    __00    __00    __00    __00 

___Layer 3___
        0       1       2       3       4       5       6       7       8       9 
0|   __10    __10    __10    __10    __10    __10 LBRC_10    M_10 COMM_10    __10 
1|   __10  SFT_10    __10    __10    __10    __10    L_10    W_10  GRV_10    __10 
2|   __10 SCLN_10    __10    __10  SFT_11  SFT_11    __10    __10    __10    __10 
3|   __00    __00    __00 BSLS_10    C_10    __10    __10    __00    __00    __00 

"""
effort_layer = """
     0    1    2    3    4    5    6    7    8    9 
0| 7.0  2.0  2.0  2.0  7.0  7.0  2.0  2.0  2.0  7.0 
1| 3.0  1.0  1.0  1.0  3.0  3.0  1.0  1.0  1.0  3.0 
2| 5.0  3.0  3.0  3.0  8.0  8.0  3.0  3.0  3.0  5.0 
3|10.0  7.0  4.0  2.0  1.0  1.0  2.0  4.0  7.0 10.0 
"""
phalanx_layer = """
     0    1    2    3    4    5    6    7    8    9 
0| L:P  L:R  L:M  L:I  L:I  R:I  R:I  R:M  R:R  R:P 
1| L:P  L:R  L:M  L:I  L:I  R:I  R:I  R:M  R:R  R:P 
2| L:P  L:R  L:M  L:I  L:I  R:I  R:I  R:M  R:R  R:P 
3| L:P  L:R  L:T  L:T  L:T  R:T  R:T  R:T  R:R  R:P 
"""

[layout_optimizer_config]
valid_keycodes = ["_A", "_B", "_C", "_D", "_E", "_F", "_G", "_H", "_I", "_J", "_K", "_L", "_M", "_N", "_O", "_P", "_Q", "_R", "_S", "_T", "_U", "_V", "_W", "_X", "_Y", "_Z", "_SPC", "_SFT", "_ENT", "_COMM", "_DOT", "_MINS", "_GRV", "_QUOT", "_SCLN", "_EQL", "_SLSH", "_BSLS", "_LBRC", "_RBRC"]
num_threads = 16

[layout_optimizer_config.genetic_options]
population_size = 1000
generation_count = 20
fitness_cutoff = 0.1
swap_weight = 2.0
replace_weight = 1.0

[layout_optimizer_config.keycode_options]
include_alphas = true
include_numbers = false
include_number_symbols = false
include_brackets = false
include_misc_symbols = true
include_misc_symbols_shifted = false
explicit_inclusions = ["_SPC", "_SFT", "_ENT"]

[layout_optimizer_config.dataset_options]
dataset_paths = ["~/coding/rustprog/alc/alc-rs/data/rust_book_test/", "~/coding/rustprog/alc/alc-rs/data/rust_book/"]
dataset_weights = [0.1, 1.0]
max_ngram_size = 4
top_n_ngrams_to_take = 100

[layout_optimizer_config.score_options]
hand_alternation_weight = 3.0
finger_roll_weight = 2.0
hand_alternation_reduction_factor = 0.8
finger_roll_reduction_factor = 0.8
finger_roll_same_row_reduction_factor = 0.9
same_finger_penalty_factor = 5.0
extra_length_penalty_factor = 1.2

# [Autogenerated]
# Option info (note: some descriptions may not be totally accurate due to complexity, but the general idea should be present.)

# [layout_info]
# num_rows: Number of rows in the layout. Note that some row x column combinations may not exist, in which case use the next size up and block key positions as necessary. Available sizes should be listed here at some point: 
# num_cols: Number of columns in the layout.
# layout: Collection of layers. Each key is of the format {{keycode}}_{{moveability flag}}{{symmetry flag}}. Keycode reference should be available here: . Moveability of 1 means the optimizer can change the key in the given position; otherwise, the key will be fixed. Symmetry of 1 means it and its corresponding symmetric key will be locked in symmetry -- if one moves, the other will be moved to the corresponding symmetric location.
# effort_layer: Specify the relative effort required to reach each key position. Smaller number means lower effort. Recommended to make the most accessible keys a weight of 1 and scale other keys accordingly. Does require some tinkering to create a grid that works for you.
# phalanx_layer: Specify which hand and finger you want to use for each key. Used in calculating hand alternation bonuses, roll bonuses, and same finger penalties. Format is {{hand}}:{{finger}}, with hand options (L)eft and (R)ight and finger options (T)humb, (I)ndex, (M)iddle, (R)ing, (P)inkie, and (J)oint. Joint refers to where your pinkie meets your palm; some users use this part of their hand to hit the bottom left- / bottom right-most keys.

# [layout_optimizer_config]
# valid_keycodes: Recommended to leave empty, as these will be generated from keycode options. If keycodes are supplied here, they will override keycode options; however, you can simply use the options + `explicit_inclusions` to fine tune the set you want, rather than having to list everything out here.
# num_threads: For each generation, score calculation can be parallelized over the layouts.

# [layout_optimizer_config.genetic_options]
# population_size: Number of layouts per generation.
# generation_count: Number of generations.
# fitness_cutoff: Keep this proportion of best layouts per generation.
# swap_weight: swap_weight:replace_weight represents the ratio of swap mutations (i.e., swapping two keys) to replace mutations (i.e., replacing one key with another). For example, 2:1 means 2/(2 + 1) of the mutations will be swaps and the remaining 1/(2 + 1) will be replaces.
# replace_weight: See swap_weight.

# [layout_optimizer_config.keycode_options]
# include_alphas: Whether to include alphabet keycodes, e.g., "z" in the text is translated to keycode _Z. Should generally be set to true.
# include_numbers: Whether to include number keycodes, e.g., "1" in the text translates to keycode _1. Recommended to set this to false and manually place numbers yourself since optimized layouts cannot currently guarantee numbers to be arranged in order.
# include_number_symbols: Whether to include shifted numbers (!@#$ etc.). If false, then, for example, "@" is translated to "_SFT" + "2". Recommended to set this to false for similar reasons as numbers. For specific symbols, such as ones common to programming languages, include them in `explicit_inclusionss`.
# include_brackets: Whether to include ()[]{}<>. Recommended to set to false and manually place brackets yourself, as optimized layouts cannot guarantee corresponding brackets will appear next to each other.
# include_misc_symbols: Whether to include -=\;'`/[]. Recommended to set to true, as these are generally needed for typing.
# include_misc_symbols_shifted: Whether to include shifted versions of misc. symbols, i.e., _+|:"~?{}. Recommended to set to false and access through shift.
# explicit_inclusions: Keycodes to explicitly include. If no combination of options covers exactly what you want, add them here.

# [layout_optimizer_config.dataset_options]
# dataset_paths: Path to directories containing files of text data. Currently only looks in the immediate directory and does not look recursively. Eventually will have presets.
# dataset_weights: Ratio of datasets' importance. For example, with two datasets at a 2:1 ratio, the first dataset will constitute 2/(2 + 1) of the score and the second will constitute 1/(2 + 1).
# max_ngram_size: Maximum length of ngrams to extract from text.
# top_n_ngrams_to_take: Number of most frequent ngrams to include. Some ngrams barely occur, thus having very little impact on overall score, so excluding them can decrease runtime. Applies to all ngrams. For example, if this value is 50, then we take the top 50 characters, top 50 bigrams, top 50 trigrams, etc.

# [layout_optimizer_config.score_options]
# hand_alternation_weight: hand_alteration_weight:finger_roll_weight represents the importance of hand alternating vs. finger rolls.
# finger_roll_weight: See `hand_alteration_weight`.
# hand_alternation_reduction_factor: When a sequence of at least 3 keys alternates hands, multiply the effort of that sequence by this factor.
# finger_roll_reduction_factor: When a sequence of at least 3 keys is a finger roll, multiply the effort of that sequence by this factor. Sequential keys that cross two or more rows are not eligible for rolls. Inner and outer rolls are weighed the same (for now).
# finger_roll_same_row_reduction_factor: If a roll occurs where all fingers are in the same row, multiply the effort of that sequence by this factor, on top of the standard roll reduction factor. In other words, rolls where all keys are in the same row are extra favorable.
# same_finger_penalty_factor: If the same finger (on the same hand, of course) is used twice in a row, multiply the effort by this factor. In other words, repeating the same finger is unfavorable.
# extra_length_penalty_factor: If the keycode sequence is longer than the ngram (e.g., from layer switches or shifting), apply this penalty for each additional key, exponentially.
